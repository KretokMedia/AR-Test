<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Place Screen</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script>
AFRAME.registerComponent("touch-transform", {
  schema: {
    minScale: { default: 0.01 },
    maxScale: { default: 2.0 },
    rotateSpeed: { default: 1.0 }
  },

  init: function () {
    this.canvas = null;
    this.enabled = false;

    this.mode = null; // "rotate" | "pinch"
    this.startScale = 1;
    this.startRotY = 0;

    this.startX = 0;

    this.startDist = 0;
    this.startAngle = 0;

    const getDist = (a, b) => {
      const dx = a.clientX - b.clientX;
      const dy = a.clientY - b.clientY;
      return Math.hypot(dx, dy);
    };

    const getAngle = (a, b) => Math.atan2(b.clientY - a.clientY, b.clientX - a.clientX);

    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

    // Wait until A-Frame has a canvas
    this.el.sceneEl.addEventListener("renderstart", () => {
      this.canvas = this.el.sceneEl.canvas;
      if (!this.canvas) return;

      // Prevent browser gestures (scroll/zoom/back swipe) on the canvas
      this.canvas.style.touchAction = "none";

      // Bind to canvas (NOT window)
      this.canvas.addEventListener("touchstart", this.onTouchStart, { passive: false });
      this.canvas.addEventListener("touchmove", this.onTouchMove, { passive: false });
      this.canvas.addEventListener("touchend", this.onTouchEnd, { passive: false });
      this.canvas.addEventListener("touchcancel", this.onTouchEnd, { passive: false });
    });

    // Enable transforms only after the model is visible (placed)
    const observer = new MutationObserver(() => {
      const v = this.el.getAttribute("visible");
      this.enabled = (v === true || v === "true");
    });
    observer.observe(this.el, { attributes: true, attributeFilter: ["visible"] });
    this._observer = observer;

    // Handlers must be bound to this
    this.onTouchStart = (e) => {
      if (!this.enabled) return;
      if (e.touches.length === 0) return;

      e.preventDefault();

      // Pinch mode
      if (e.touches.length >= 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];

        this.mode = "pinch";
        this.startScale = this.el.object3D.scale.x;
        this.startRotY = this.el.object3D.rotation.y;

        this.startDist = getDist(t1, t2);
        this.startAngle = getAngle(t1, t2);
        return;
      }

      // Rotate mode (one finger)
      if (e.touches.length === 1) {
        const t = e.touches[0];
        this.mode = "rotate";
        this.startX = t.clientX;
        this.startRotY = this.el.object3D.rotation.y;
      }
    };

    this.onTouchMove = (e) => {
      if (!this.enabled) return;
      if (e.touches.length === 0) return;

      e.preventDefault();

      // If two fingers are down, ALWAYS treat as pinch (donâ€™t rotate)
      if (e.touches.length >= 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];

        // Scale
        const dist = getDist(t1, t2);
        const ratio = dist / (this.startDist || dist);
        let s = this.startScale * ratio;
        s = clamp(s, this.data.minScale, this.data.maxScale);
        this.el.object3D.scale.set(s, s, s);

        // Optional: gentle twist rotate around Y
        const angle = getAngle(t1, t2);
        const delta = angle - this.startAngle;
        this.el.object3D.rotation.y = this.startRotY + delta;

        this.mode = "pinch";
        return;
      }

      // One finger rotate
      if (e.touches.length === 1 && this.mode === "rotate") {
        const t = e.touches[0];
        const dx = t.clientX - this.startX;
        this.el.object3D.rotation.y = this.startRotY + (dx * 0.01 * this.data.rotateSpeed);
      }
    };

    this.onTouchEnd = (e) => {
      if (!this.enabled) return;
      e.preventDefault();

      // When fingers change count, reset baseline so it doesn't jump
      if (e.touches.length === 1) {
        const t = e.touches[0];
        this.mode = "rotate";
        this.startX = t.clientX;
        this.startRotY = this.el.object3D.rotation.y;
      } else if (e.touches.length >= 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];
        this.mode = "pinch";
        this.startScale = this.el.object3D.scale.x;
        this.startRotY = this.el.object3D.rotation.y;
        this.startDist = getDist(t1, t2);
        this.startAngle = getAngle(t1, t2);
      } else {
        this.mode = null;
      }
    };
  },

  remove: function () {
    if (this._observer) this._observer.disconnect();
    if (this.canvas) {
      this.canvas.removeEventListener("touchstart", this.onTouchStart);
      this.canvas.removeEventListener("touchmove", this.onTouchMove);
      this.canvas.removeEventListener("touchend", this.onTouchEnd);
      this.canvas.removeEventListener("touchcancel", this.onTouchEnd);
    }
  }
});
</script>

  </head>

  <body style="margin:0; overflow:hidden;">
    <a-scene
      xr-mode-ui="XRMode: ar"
      renderer="antialias: false; precision: mediump; colorManagement: true"
      webxr="optionalFeatures: hit-test"
      ar-hit-test="target: #screen;"
      vr-mode-ui="enabled: false">

      <a-entity
        id="screen"
        gltf-model="screen.glb"
        visible="false"
        scale="0.08 0.08 0.08"
        touch-transform="minScale: 0.02; maxScale: 2.5; rotateSpeed: 1.0">
      </a-entity>

      <a-camera></a-camera>
    </a-scene>
  </body>
</html>


