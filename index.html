<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Place Screen - Controls</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>

    <style>
      body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
      #ui {
        position: fixed;
        left: 0; right: 0; bottom: 0;
        padding: 10px;
        display: flex;
        gap: 8px;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        pointer-events: none; /* allow AR touches through except on buttons */
      }
      .btn {
        pointer-events: auto;
        border: 0;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(0,0,0,0.65);
        color: white;
        font-size: 14px;
      }
      .btn.active { background: rgba(255,255,255,0.9); color: black; }
      .btn.small { padding: 10px 14px; font-weight: 700; }
      #hint {
        position: fixed;
        left: 0; right: 0; bottom: 56px;
        text-align: center;
        color: white;
        font-size: 13px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>

  <body>
    <div id="hint">Tap to place. Then use buttons: Move / Rotate / Scale.</div>

    <div id="ui">
      <button id="moveBtn" class="btn active">Move</button>
      <button id="rotBtn" class="btn">Rotate</button>
      <button id="scaleBtn" class="btn">Scale</button>
      <button id="minusBtn" class="btn small">−</button>
      <button id="plusBtn" class="btn small">+</button>
    </div>

    <a-scene
      xr-mode-ui="XRMode: ar"
      renderer="antialias: false; precision: mediump; colorManagement: true"
      webxr="optionalFeatures: hit-test"
      ar-hit-test="target: #screen;"
      vr-mode-ui="enabled: false">

      <a-entity
        id="screen"
        gltf-model="screen.glb"
        visible="false"
        scale="0.08 0.08 0.08">
      </a-entity>

      <a-camera></a-camera>
    </a-scene>

    <script>
      const screenEl = document.querySelector("#screen");
      const sceneEl = document.querySelector("a-scene");

      // UI
      const moveBtn = document.getElementById("moveBtn");
      const rotBtn = document.getElementById("rotBtn");
      const scaleBtn = document.getElementById("scaleBtn");
      const plusBtn = document.getElementById("plusBtn");
      const minusBtn = document.getElementById("minusBtn");
      const hint = document.getElementById("hint");

      let mode = "move"; // "move" | "rotate" | "scale"
      let placed = false;

      const setMode = (m) => {
        mode = m;
        moveBtn.classList.toggle("active", m === "move");
        rotBtn.classList.toggle("active", m === "rotate");
        scaleBtn.classList.toggle("active", m === "scale");
        hint.textContent = placed
          ? (m === "move" ? "Drag left/right/up/down to move." :
             m === "rotate" ? "Drag left/right to rotate." :
                              "Drag left/right to scale, or use + / −.")
          : "Tap to place. Then use buttons: Move / Rotate / Scale.";
      };

      moveBtn.onclick = () => setMode("move");
      rotBtn.onclick = () => setMode("rotate");
      scaleBtn.onclick = () => setMode("scale");

      // Reliable scale buttons
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      const scaleBy = (factor) => {
        const s = screenEl.object3D.scale.x;
        const next = clamp(s * factor, 0.02, 2.5);
        screenEl.object3D.scale.set(next, next, next);
      };
      plusBtn.onclick = () => scaleBy(1.15);
      minusBtn.onclick = () => scaleBy(0.87);

      // Detect when A-Frame makes it visible (first placement)
      const obs = new MutationObserver(() => {
        const v = screenEl.getAttribute("visible");
        placed = (v === true || v === "true");
        if (placed) setMode(mode);
      });
      obs.observe(screenEl, { attributes: true, attributeFilter: ["visible"] });

      // Drag controls (single finger drag)
      let dragging = false;
      let startX = 0, startY = 0;
      let startRotY = 0;
      let startPos = { x: 0, y: 0, z: 0 };
      let startScale = 0.08;

      // Attach to canvas once it exists
      sceneEl.addEventListener("renderstart", () => {
        const canvas = sceneEl.canvas;
        canvas.style.touchAction = "none";

        canvas.addEventListener("pointerdown", (e) => {
          if (!placed) return; // don't interfere with tap-to-place
          // Ignore touches on UI
          if (e.target.closest && e.target.closest("#ui")) return;

          dragging = true;
          startX = e.clientX;
          startY = e.clientY;

          startRotY = screenEl.object3D.rotation.y;
          const p = screenEl.object3D.position;
          startPos = { x: p.x, y: p.y, z: p.z };
          startScale = screenEl.object3D.scale.x;
        });

        canvas.addEventListener("pointermove", (e) => {
          if (!dragging || !placed) return;

          const dx = (e.clientX - startX);
          const dy = (e.clientY - startY);

          // Tune these to taste
          const moveSpeed = 0.0025;  // meters per pixel (ish)
          const rotSpeed  = 0.008;   // radians per pixel
          const scaleSpeed = 0.002;  // scale per pixel

          if (mode === "move") {
            // Move along X/Z plane relative to screen
            // (simple mapping: drag up/down moves forward/back)
            screenEl.object3D.position.x = startPos.x + dx * moveSpeed;
            screenEl.object3D.position.z = startPos.z + dy * moveSpeed;
          } else if (mode === "rotate") {
            screenEl.object3D.rotation.y = startRotY + dx * rotSpeed;
          } else if (mode === "scale") {
            const next = clamp(startScale + dx * scaleSpeed, 0.02, 2.5);
            screenEl.object3D.scale.set(next, next, next);
          }
        });

        const end = () => { dragging = false; };
        canvas.addEventListener("pointerup", end);
        canvas.addEventListener("pointercancel", end);
        canvas.addEventListener("pointerleave", end);
      });

      // Initial hint state
      setMode("move");
    </script>
  </body>
</html>
