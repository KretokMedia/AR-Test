<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Place Screen - 2-Finger Rotate</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>

    <style>
      body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }

      #overlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        pointer-events: none; /* allow touches to reach AR, unless we enable specific zones */
      }

      /* Optional deadzone at bottom so you can't place/move there */
      #deadzone {
        position: absolute;
        left: 0; right: 0; bottom: 0;
        height: 120px;            /* adjust */
        pointer-events: auto;     /* capture touches here */
        background: rgba(0,0,0,0);
        display: none;
        touch-action: none;
      }

      #hint {
        position: absolute;
        left: 0; right: 0; bottom: 18px;
        text-align: center;
        color: white;
        font-size: 13px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        padding: 10px 12px;
        pointer-events: none;
        display: none;
      }
    </style>
  </head>

  <body>
    <div id="overlay">
      <div id="deadzone"></div>
      <div id="hint">1 finger: move/place • 2 fingers: rotate</div>
    </div>

    <a-scene
      xr-mode-ui="XRMode: ar"
      renderer="antialias: false; precision: mediump; colorManagement: true"
      webxr="optionalFeatures: hit-test, dom-overlay; overlayElement: #overlay"
      ar-hit-test="target: #screen; enabled: true"
      vr-mode-ui="enabled: false">

      <!--
        #screen = placed entity (position controlled by hit-test)
        #yaw    = rotation pivot (we rotate this with 2-finger gesture)
        #model  = glb, with optional 180° correction
      -->
      <a-entity id="screen" visible="true" scale="0.3 0.3 0.3">
        <a-entity id="yaw" rotation="0 0 0">
          <a-entity id="model" gltf-model="screen.glb" rotation="0 180 0"></a-entity>
        </a-entity>
      </a-entity>

      <a-camera></a-camera>
    </a-scene>

    <script>
      const sceneEl  = document.querySelector("a-scene");
      const screenEl = document.querySelector("#screen");
      const yawEl    = document.querySelector("#yaw");

      const hint = document.getElementById("hint");
      const deadzone = document.getElementById("deadzone");

      let placed = false;
      let inAR = false;

      // --- Hit-test enable/disable (prevents unintended moves while rotating) ---
      function setHitTestEnabled(enabled) {
        sceneEl.setAttribute("ar-hit-test", { target: "#screen", enabled });
      }

      // --- Show hint only in AR ---
      const isVisibleTrue = (v) => v === true || v === "true";

      function showUI() {
        hint.style.display = "block";
        deadzone.style.display = "block"; // comment out if you don't want deadzone
      }
      function hideUI() {
        hint.style.display = "none";
        deadzone.style.display = "none";
      }

      sceneEl.addEventListener("enter-vr", () => { inAR = true; showUI(); });
      sceneEl.addEventListener("exit-vr",  () => { inAR = false; hideUI(); });

      const obs = new MutationObserver(() => {
        placed = isVisibleTrue(screenEl.getAttribute("visible"));
      });
      obs.observe(screenEl, { attributes: true, attributeFilter: ["visible"] });

      // --- Deadzone blocks placement/move in bottom strip ---
      function swallow(e) {
        e.preventDefault?.();
        e.stopPropagation?.();
      }
      function lockPlacement(e) {
        swallow(e);
        setHitTestEnabled(false);
      }
      function unlockPlacement(e) {
        swallow(e);
        setTimeout(() => setHitTestEnabled(true), 120);
      }

      ["touchstart"].forEach(evt => deadzone.addEventListener(evt, lockPlacement, { passive: false }));
      ["touchend","touchcancel"].forEach(evt => deadzone.addEventListener(evt, unlockPlacement, { passive: false }));

      // =========================================================
      // 2-FINGER ROTATION (reliable, no buttons)
      // =========================================================

      // Track active touches (we rely on touch events)
      let rotating = false;
      let lastAvgX = 0;

      // Degrees per pixel of horizontal movement (tweak as needed)
      const ROT_SENSITIVITY = 0.25;

      // Attach touch listeners to the overlay (DOM overlay supports this in WebXR)
      // But we also attach to document as fallback.
      const touchTarget = document.getElementById("overlay");

      function getAvgX(touches) {
        // average X of the first two touches
        const x1 = touches[0].clientX;
        const x2 = touches[1].clientX;
        return (x1 + x2) / 2;
      }

      function rotateByDegrees(deg) {
        if (!placed) return;
        const r = yawEl.getAttribute("rotation") || { x: 0, y: 0, z: 0 };
        yawEl.setAttribute("rotation", { x: r.x, y: r.y + deg, z: r.z });
      }

      function onTouchStart(e) {
        // If user has 2 fingers down => start rotating mode
        if (!inAR) return;

        if (e.touches && e.touches.length === 2) {
          // prevent AR select/move while rotating
          swallow(e);
          setHitTestEnabled(false);

          rotating = true;
          lastAvgX = getAvgX(e.touches);
        }
        // 1 finger: do nothing (let hit-test place/move as normal)
      }

      function onTouchMove(e) {
        if (!inAR) return;

        if (rotating && e.touches && e.touches.length === 2) {
          swallow(e);

          const avgX = getAvgX(e.touches);
          const dx = avgX - lastAvgX;
          lastAvgX = avgX;

          rotateByDegrees(dx * ROT_SENSITIVITY);
        }
      }

      function onTouchEnd(e) {
        if (!inAR) return;

        // If we drop below 2 touches, stop rotating and re-enable hit-test
        if (!e.touches || e.touches.length < 2) {
          if (rotating) {
            rotating = false;
            // small delay so the XR select from this gesture doesn't move it
            setTimeout(() => setHitTestEnabled(true), 140);
          }
        }
      }

      // Attach to overlay (primary)
      touchTarget.addEventListener("touchstart", onTouchStart, { passive: false });
      touchTarget.addEventListener("touchmove",  onTouchMove,  { passive: false });
      touchTarget.addEventListener("touchend",   onTouchEnd,   { passive: false });
      touchTarget.addEventListener("touchcancel",onTouchEnd,   { passive: false });

      // Fallback attach to document (some builds deliver touches here)
      document.addEventListener("touchstart", onTouchStart, { passive: false });
      document.addEventListener("touchmove",  onTouchMove,  { passive: false });
      document.addEventListener("touchend",   onTouchEnd,   { passive: false });
      document.addEventListener("touchcancel",onTouchEnd,   { passive: false });
    </script>
  </body>
</html>

